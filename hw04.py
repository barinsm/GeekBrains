#Урок 4. Эмпирическая оценка алгоритмов на Python

#1. Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания первых трех уроков.
#Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.
"""
На примере Задания 4 в уроке 2:
4. Найти сумму n элементов следующего ряда чисел: 1 -0.5 0.25 -0.125 ...
Количество элементов (n) вводится с клавиатуры.
"""
import timeit

# цикл
def loop(n):
    a = 1
    i = 0
    summ = 0
    while i < n:
        summ += a
        a = a / 2 * -1
        i += 1
    return summ

# рекурсия
def recursion(n, i=0, num=1, summ=0):
    if i == n:
        return summ
    elif i < n:
        return recursion(n, i+1, num/(-2), summ+num)

n = int(input("Введите количество элементов: "))
# print(loop(n))
# print(recursion(n))
print(timeit.timeit('loop(n)', setup='from __main__ import n,loop', number= 1000))
print(timeit.timeit('recursion(n)', setup='from __main__ import n,recursion', number= 1000))

"""
При небольшом N<=100 обе реализации алгоритма считают примерно одинаково
(например, при N=100 и 1000 повторных расчетов длятся 0,023 и 0,024 секунды),
но уже при N>=200 регресия отстает и может считать до 2 раз дольше чем цикл,
видимо, связано с дополнительными вызовами вложенных функций
(например, при N=1000 и 1000 повторных расчетов длятся 0,16 и 0,30 секунды).
Сложность алгоритма в обоих случаях линейная O(n)
"""

#2. Написать два алгоритма нахождения i-го по счёту простого числа.
#Без использования «Решета Эратосфена»;
#Используя алгоритм «Решето Эратосфена»
#Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов. Результаты анализа сохранить в виде комментариев в файле с кодом.

